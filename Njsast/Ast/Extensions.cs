using System;
using Njsast.AstDump;
using Njsast.Reader;

namespace Njsast.Ast;

public static class Extensions
{
    public static bool IsExpression(this AstNode node)
    {
        return node is AstUnary or AstBinary or AstConstant or AstConditional or AstSequence or AstObject or AstArray
            or AstClassExpression or AstArrow or AstFunction or AstPropAccess or AstCall or AstTemplateString
            or AstPrefixedTemplateString or AstSymbolRef or AstAwait;
    }

    public static string? IsGlobalSymbol(this SymbolDef? symbol)
    {
        return symbol is { Undeclared: true, Global: true } ? symbol.Name : null;
    }

    public static bool IsRequireSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "require";

    public static bool IsExportsSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "exports";

    public static bool IsPromiseSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "Promise";

    public static bool IsProcessSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "process";

    public static bool IsTsReexportSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "__exportStar";

    public static bool IsParentScopeFor(this AstScope parentScope, AstScope? potentiallyNestedScope)
    {
        var scope = potentiallyNestedScope;
        while (scope != null)
        {
            if (scope == parentScope)
                return true;
            scope = scope.ParentScope;
        }

        return false;
    }

    public static string? IsRequireCall(this AstNode? node)
    {
        if (node is not AstCall { Args.Count: 1, Expression: AstSymbol methodNameSymbol } call ||
            !methodNameSymbol.Thedef.IsRequireSymbol()) return null;
        var arg = call.Args[0];
        if (arg is AstString str)
            return str.Value;

        return null;
    }

    /// Detects process.env.RESULT pattern
    public static string? IsProcessEnv(this AstNode? node)
    {
        if (node is AstPropAccess { Expression: AstDot dot } propAccess &&
            dot.Expression.IsSymbolDef().IsProcessSymbol() && dot.PropertyAsString == "env")
        {
            return propAccess.PropertyAsString;
        }

        return null;
    }

    //Detect this pattern and success return require const parameter "./lib"
    //Promise.resolve().then(function() {
    //    return require("./lib");
    //})
    //Because this pattern is generated by TypeScript compiler when using: import("./lib")
    public static string? IsLazyImportCall(this AstNode node)
    {
        switch (node)
        {
            case AstImportExpression import:
            {
                var arg = import.ModuleName;
                if (arg is AstString str)
                    return str.Value;
                return null;
            }
            case AstCall { Args.Count: 1 } call:
            {
                var then = call.Expression;
                if (then is AstDot dot && dot.Property as string == "then")
                {
                    if (dot.Expression is AstCall { Args.Count: 0 } resolveCall)
                    {
                        if (resolveCall.Expression is AstDot resolveExpr &&
                            resolveExpr.Property as string == "resolve")
                        {
                            var promiseRef = resolveExpr.Expression;
                            if (promiseRef is not AstSymbolRef symbol || !symbol.Thedef.IsPromiseSymbol())
                                return null;
                        }
                        else return null;
                    }
                    else return null;
                }
                else return null;

                if (
                    call.Args[0] is AstFunction { ArgNames.Count: 0, Body.Count: 1 } argumentFunction)
                {
                    if (argumentFunction.Body[0] is AstReturn returnStatement)
                        return returnStatement.Value.IsRequireCall();
                }

                break;
            }
        }

        return null;
    }

    public static SymbolDef? IsSymbolDef(this AstNode? node)
    {
        if (node is AstSymbol symbol) return symbol.Thedef;
        return null;
    }

    public static (string name, AstNode value)? IsExportsAssign(this AstNode node, bool allowLocalExports = false)
    {
        if (node is AstSimpleStatement simpleStatement)
        {
            node = simpleStatement.Body;
        }

        if (node is not AstAssign { Operator: Operator.Assignment, Left: AstPropAccess propAccess } assign) return null;
        if (allowLocalExports)
        {
            if (propAccess.Expression is not AstSymbolRef { Name: "exports" }) return null;
        }
        else
        {
            if (!propAccess.Expression.IsSymbolDef().IsExportsSymbol()) return null;
        }

        var name = propAccess.PropertyAsString;
        if (name != null) return (name, assign.Right);
        return null;
    }

    /// return true is parameter is Object.defineProperty(exports, "__esModule", { value: true })
    public static bool IsDefinePropertyExportsEsModule(this AstNode node)
    {
        if (node is AstCall call)
        {
            if (call.Args.Count != 3) return false;
            if (call.Args[0] is not AstSymbolRef { Name: "exports" } ||
                call.Args[1] is not AstString { Value: "__esModule" }) return false;
            if (call.Expression is not AstPropAccess { PropertyAsString: "defineProperty" } propAccess) return false;
            return propAccess.Expression is AstSymbolRef { Name: "Object" };
        }

        if (node is AstSimpleStatement simpleStatement)
        {
            return simpleStatement.Body.IsDefinePropertyExportsEsModule();
        }

        return false;
    }

    public static bool IsConstantSymbolRef(this AstNode? node)
    {
        var def = node.IsSymbolDef();
        if (def == null) return false;
        if (def.Undeclared) return false;
        return def.IsSingleInitAndDeeplyConst;
    }

    public static T DeepClone<T>(this T node) where T : AstNode
    {
        var tr = new DeepCloneTransformer();
        return (T)tr.Transform(node);
    }

    public static string DumpToString(this AstNode node, bool withoutPositions = false)
    {
        var strSink = new StringLineSink();
        var dumper = new DumpAst(new AstDumpWriter(strSink, withoutPositions));
        dumper.Walk(node);
        return strSink.ToString();
    }
}
