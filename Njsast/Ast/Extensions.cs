using Njsast.AstDump;
using Njsast.Reader;

namespace Njsast.Ast
{
    public static class Extensions
    {
        public static string? IsGlobalSymbol(this SymbolDef? symbol)
        {
            if (symbol != null && symbol.Undeclared && symbol.Global) return symbol.Name;
            return null;
        }

        public static bool IsRequireSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "require";

        public static bool IsExportsSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "exports";

        public static bool IsPromiseSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "Promise";

        public static bool IsProcessSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "process";

        public static bool IsTsReexportSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol) == "__exportStar";

        public static bool IsParentScopeFor(this AstScope parentScope, AstScope? potentiallyNestedScope)
        {
            var scope = potentiallyNestedScope;
            while (scope != null)
            {
                if (scope == parentScope)
                    return true;
                scope = scope.ParentScope;
            }

            return false;
        }

        public static string? IsRequireCall(this AstNode? node)
        {
            if (!(node is AstCall call) || call.Args.Count != 1 || !(call.Expression is AstSymbol methodNameSymbol) ||
                !methodNameSymbol.Thedef.IsRequireSymbol()) return null;
            var arg = call.Args[0];
            if (arg is AstString str)
                return str.Value;

            return null;
        }

        /// Detects process.env.RESULT pattern
        public static string? IsProcessEnv(this AstNode? node)
        {
            if (node is AstPropAccess propAccess && propAccess.Expression is AstDot dot &&
                dot.Expression.IsSymbolDef().IsProcessSymbol() && dot.PropertyAsString == "env")
            {
                return propAccess.PropertyAsString;
            }

            return null;
        }

        //Detect this pattern and success return require const parameter "./lib"
        //Promise.resolve().then(function() {
        //    return require("./lib");
        //})
        //Because this pattern is generated by TypeScript compiler when using: import("./lib")
        public static string? IsLazyImportCall(this AstNode node)
        {
            switch (node)
            {
                case AstImportExpression import:
                {
                    var arg = import.ModuleName;
                    if (arg is AstString str)
                        return str.Value;
                    return null;
                }
                case AstCall call when call.Args.Count == 1:
                {
                    var then = call.Expression;
                    if (then is AstDot dot && dot.Property as string == "then")
                    {
                        if (dot.Expression is AstCall resolveCall && resolveCall.Args.Count == 0)
                        {
                            if (resolveCall.Expression is AstDot resolveExpr &&
                                resolveExpr.Property as string == "resolve")
                            {
                                var promiseRef = resolveExpr.Expression;
                                if (!(promiseRef is AstSymbolRef symbol) || !symbol.Thedef.IsPromiseSymbol())
                                    return null;
                            }
                            else return null;
                        }
                        else return null;
                    }
                    else return null;

                    if (
                        call.Args[0] is AstFunction argumentFunction &&
                        argumentFunction.ArgNames.Count == 0)
                    {
                        if (argumentFunction.Body.Count == 1)
                        {
                            if (argumentFunction.Body[0] is AstReturn returnStatement)
                                return returnStatement.Value.IsRequireCall();
                        }
                    }

                    break;
                }
            }

            return null;
        }

        public static SymbolDef? IsSymbolDef(this AstNode? node)
        {
            if (node is AstSymbol symbol) return symbol.Thedef;
            return null;
        }

        public static (string name, AstNode? value)? IsExportsAssign(this AstNode node, bool allowLocalExports = false)
        {
            if (node is AstSimpleStatement simpleStatement)
            {
                node = simpleStatement.Body;
            }

            if (!(node is AstAssign assign)) return null;
            if (assign.Operator != Operator.Assignment) return null;
            if (!(assign.Left is AstPropAccess propAccess)) return null;
            if (allowLocalExports)
            {
                if (!(propAccess.Expression is AstSymbolRef symb) || symb.Name != "exports") return null;
            }
            else
            {
                if (!propAccess.Expression.IsSymbolDef().IsExportsSymbol()) return null;
            }
            var name = propAccess.PropertyAsString;
            if (name != null) return (name, assign.Right);
            return null;
        }

        /// return true is parameter is Object.defineProperty(exports, "__esModule", { value: true })
        public static bool IsDefinePropertyExportsEsModule(this AstNode node)
        {
            if (node is AstCall call)
            {
                if (call.Args.Count != 3 || !call.Args[0].IsSymbolDef().IsExportsSymbol()) return false;
                if (!(call.Expression is AstPropAccess propAccess)) return false;
                if (propAccess.PropertyAsString != "defineProperty") return false;
                return propAccess.Expression.IsSymbolDef().IsGlobalSymbol() == "Object";
            }

            if (node is AstSimpleStatement simpleStatement)
            {
                return simpleStatement.Body.IsDefinePropertyExportsEsModule();
            }

            return false;
        }

        public static bool IsConstantSymbolRef(this AstNode? node)
        {
            var def = node.IsSymbolDef();
            if (def == null) return false;
            if (def.Undeclared) return false;
            return def.IsSingleInit;
        }

        public static T DeepClone<T>(this T node) where T : AstNode
        {
            var tr = new DeepCloneTransformer();
            return (T) tr.Transform(node);
        }

        public static string DumpToString(this AstNode node, bool withoutPositions = false)
        {
            var strSink = new StringLineSink();
            var dumper = new DumpAst(new AstDumpWriter(strSink, withoutPositions));
            dumper.Walk(node);
            return strSink.ToString();
        }
    }
}
